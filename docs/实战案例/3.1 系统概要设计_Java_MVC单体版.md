# 知识图谱可视化与管理平台 - 系统概要设计（Java技术栈单体部署版）

## 1. 设计概述

### 1.1 技术栈重构背景
基于《系统设计需求.md》中"### 7.1 技术约束"的严格要求，本设计将系统架构从Python技术栈重构为Java技术栈，实现企业级单体部署架构。

### 1.2 技术栈映射（严格遵循技术约束）

**技术约束要求** → **Java技术栈实现**：
- ✅ **前端**：React + TypeScript + AntV G6（保持不变）
- ✅ **后端**：Spring Boot + TinkerPop Gremlin Server（Spring Boot + Gremlin驱动）
- ✅ **图数据库**：JanusGraph（完整支持TinkerPop）
- ✅ **通信**：WebSocket/HTTP2（Spring WebFlux + WebSocket）
- ✅ **单体部署**：Spring Boot内嵌Tomcat + 前端打包集成

### 1.3 技术选型清单

| 层级 | 技术选型 | 版本 | 作用 |
|------|----------|------|------|
| **前端** | React | 18.x | 用户界面框架 |
| | TypeScript | 5.x | 类型安全 |
| | AntV G6 | 4.x | 图可视化引擎 |
| | Ant Design | 5.x | UI组件库 |
| **后端** | Spring Boot | 3.2.x | 应用框架 |
| | Spring Web | 6.x | Web服务 |
| | Spring Data | 3.x | 数据访问 |
| | TinkerPop Gremlin | 3.7.x | 图查询语言 |
| | JanusGraph | 1.0.x | 图数据库 |
| **数据库** | JanusGraph | 1.0.x | 主图数据库 |
| | H2 Database | 2.2.x | 开发环境 |
| | PostgreSQL | 15.x | 生产环境 |
| **构建** | Maven | 3.9.x | 依赖管理 |
| | Node.js | 18.x | 前端构建 |
| **部署** | Spring Boot | 3.2.x | 内嵌Tomcat |
| | Docker | 24.x | 容器化部署 |

## 2. 系统架构设计

### 2.1 单体架构图（Java技术栈）

```
┌─────────────────────────────────────────────────────────────────┐
│                        用户浏览器层                                 │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │                    React + AntV G6                           │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │ │
│  │  │  知识图谱   │  │   数据管理   │  │   知识本体   │            │ │
│  │  │  可视化   │  │   导入导出   │  │   管理    │            │ │
│  │  └─────────────┘  └─────────────┘  └─────────────┘            │ │
│  └───────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────┤
│                        API网关层                                   │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │              Spring Boot Web服务                              │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │ │
│  │  │  REST API │  │  WebSocket  │  │   GraphQL   │            │ │
│  │  │  控制器   │  │   实时通信   │  │   查询接口   │            │ │
│  │  └─────────────┘  └─────────────┘  └─────────────┘            │ │
│  └───────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────┤
│                        业务逻辑层                                   │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │              Spring Service层                                │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │ │
│  │  │  图谱服务   │  │  可视化   │  │  邮件处理   │            │ │
│  │  │  Gremlin  │  │   服务    │  │   服务    │            │ │
│  │  └─────────────┘  └─────────────┘  └─────────────┘            │ │
│  └───────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────┤
│                        数据访问层                                   │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │              Repository层                                      │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │ │
│  │  │ JanusGraph  │  │  关系DB    │  │   文件    │            │ │
│  │  │ Repository  │  │ Repository  │  │ Repository  │            │ │
│  │  └─────────────┘  └─────────────┘  └─────────────┘            │ │
│  └───────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────┤
│                        数据存储层                                   │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │              数据存储引擎                                      │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │ │
│  │  │ JanusGraph  │  │ PostgreSQL  │  │  文件系统   │            │ │
│  │  │ 图数据库   │  │  元数据    │  │   存储    │            │ │
│  │  └─────────────┘  └─────────────┘  └─────────────┘            │ │
│  └───────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 项目结构（Maven多模块）

```
knowledge-graph-platform/
├── pom.xml                           # 主Maven配置
├── frontend/                         # React前端模块
│   ├── package.json
│   ├── tsconfig.json
│   ├── src/
│   │   ├── components/              # React组件
│   │   ├── services/                # API服务
│   │   ├── types/                   # TypeScript类型
│   │   └── utils/                   # 工具函数
│   └── build/                       # 构建输出
├── backend/                          # Spring Boot后端
│   ├── pom.xml
│   ├── src/main/java/
│   │   └── com.knowledgegraph/
│   │       ├── KnowledgeGraphApplication.java  # 主启动类
│   │       ├── config/              # 配置类
│   │       │   ├── JanusGraphConfig.java
│   │       │   ├── WebSocketConfig.java
│   │       │   └── SecurityConfig.java
│   │       ├── controller/          # REST控制器
│   │       │   ├── GraphController.java
│   │       │   ├── VisualizationController.java
│   │       │   ├── EmailController.java
│   │       │   └── ImportExportController.java
│   │       ├── service/            # 业务服务
│   │       │   ├── GraphService.java
│   │       │   ├── VisualizationService.java
│   │       │   ├── EmailProcessingService.java
│   │       │   └── ImportExportService.java
│   │       ├── repository/         # 数据访问层
│   │       │   ├── JanusGraphRepository.java
│   │       │   ├── JpaRepository.java
│   │       │   └── FileStorageRepository.java
│   │       ├── model/             # 数据模型
│   │       │   ├── graph/
│   │       │   ├── ontology/
│   │       │   └── email/
│   │       └── util/              # 工具类
│   ├── src/main/resources/
│   │   ├── application.yml        # 应用配置
│   │   ├── application-dev.yml    # 开发环境配置
│   │   ├── application-prod.yml   # 生产环境配置
│   │   └── static/                # 静态资源
│   └── src/test/                  # 测试代码
├── docker-compose.yml              # Docker部署
├── Dockerfile                      # 容器镜像
└── README.md                       # 项目文档
```

## 3. 核心数据模型设计（Java）

### 3.1 知识图谱数据模型

#### 3.1.1 节点实体类
```java
package com.knowledgegraph.model.graph;

import java.util.Map;
import java.util.HashMap;
import java.time.LocalDateTime;

public class KGNode {
    private String id;
    private String label;
    private String nodeType;
    private Map<String, Object> properties;
    private Double x;
    private Double y;
    private Double size;
    private String color;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    public KGNode() {
        this.properties = new HashMap<>();
        this.size = 20.0;
        this.color = "#1f77b4";
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
    
    // Getters and Setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    
    public String getLabel() { return label; }
    public void setLabel(String label) { this.label = label; }
    
    public String getNodeType() { return nodeType; }
    public void setNodeType(String nodeType) { this.nodeType = nodeType; }
    
    public Map<String, Object> getProperties() { return properties; }
    public void setProperties(Map<String, Object> properties) { this.properties = properties; }
    
    public void addProperty(String key, Object value) {
        this.properties.put(key, value);
        this.updatedAt = LocalDateTime.now();
    }
    
    public Object getProperty(String key) {
        return this.properties.get(key);
    }
}
```

#### 3.1.2 边实体类
```java
package com.knowledgegraph.model.graph;

import java.util.Map;
import java.util.HashMap;
import java.time.LocalDateTime;

public class KGEdge {
    private String id;
    private String sourceId;
    private String targetId;
    private String label;
    private String edgeType;
    private Map<String, Object> properties;
    private Double weight;
    private String color;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    public KGEdge() {
        this.properties = new HashMap<>();
        this.weight = 1.0;
        this.color = "#888888";
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
    
    // Getters and Setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    
    public String getSourceId() { return sourceId; }
    public void setSourceId(String sourceId) { this.sourceId = sourceId; }
    
    public String getTargetId() { return targetId; }
    public void setTargetId(String targetId) { this.targetId = targetId; }
    
    public String getLabel() { return label; }
    public void setLabel(String label) { this.label = label; }
    
    public String getEdgeType() { return edgeType; }
    public void setEdgeType(String edgeType) { this.edgeType = edgeType; }
    
    public Map<String, Object> getProperties() { return properties; }
    public void setProperties(Map<String, Object> properties) { this.properties = properties; }
}
```

#### 3.1.3 知识图谱主类
```java
package com.knowledgegraph.model.graph;

import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.time.LocalDateTime;

public class KnowledgeGraph {
    private String id;
    private String name;
    private String description;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private Map<String, KGNode> nodes;
    private Map<String, KGEdge> edges;
    private KnowledgeOntology ontology;
    
    public KnowledgeGraph() {
        this.nodes = new HashMap<>();
        this.edges = new HashMap<>();
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
    
    public void addNode(KGNode node) {
        this.nodes.put(node.getId(), node);
        this.updatedAt = LocalDateTime.now();
    }
    
    public void addEdge(KGEdge edge) {
        this.edges.put(edge.getId(), edge);
        this.updatedAt = LocalDateTime.now();
    }
    
    public void removeNode(String nodeId) {
        this.nodes.remove(nodeId);
        // 移除相关边
        this.edges.entrySet().removeIf(entry -> 
            entry.getValue().getSourceId().equals(nodeId) || 
            entry.getValue().getTargetId().equals(nodeId));
        this.updatedAt = LocalDateTime.now();
    }
    
    public List<KGNode> getNodes() {
        return new ArrayList<>(nodes.values());
    }
    
    public List<KGEdge> getEdges() {
        return new ArrayList<>(edges.values());
    }
}
```

### 3.2 本体数据模型

#### 3.2.1 本体类定义
```java
package com.knowledgegraph.model.ontology;

import java.util.List;
import java.util.ArrayList;

public class OntologyClass {
    private String name;
    private String label;
    private String description;
    private String parent;
    private List<String> properties;
    
    public OntologyClass() {
        this.properties = new ArrayList<>();
    }
    
    // Getters and Setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getLabel() { return label; }
    public void setLabel(String label) { this.label = label; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public String getParent() { return parent; }
    public void setParent(String parent) { this.parent = parent; }
    
    public List<String> getProperties() { return properties; }
    public void setProperties(List<String> properties) { this.properties = properties; }
    
    public void addProperty(String property) {
        this.properties.add(property);
    }
}
```

#### 3.2.2 知识本体类
```java
package com.knowledgegraph.model.ontology;

import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;

public class KnowledgeOntology {
    private String id;
    private String name;
    private String description;
    private Map<String, OntologyClass> classes;
    private Map<String, OntologyProperty> properties;
    
    public KnowledgeOntology() {
        this.classes = new HashMap<>();
        this.properties = new HashMap<>();
    }
    
    public void addClass(OntologyClass ontologyClass) {
        this.classes.put(ontologyClass.getName(), ontologyClass);
    }
    
    public void addProperty(OntologyProperty property) {
        this.properties.put(property.getName(), property);
    }
    
    // Getters and Setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public Map<String, OntologyClass> getClasses() { return classes; }
    public Map<String, OntologyProperty> getProperties() { return properties; }
}
```

### 3.3 邮件处理数据模型

#### 3.3.1 邮件元数据
```java
package com.knowledgegraph.model.email;

import java.time.LocalDateTime;
import java.util.List;
import java.util.ArrayList;

public class EmailMetadata {
    private String messageId;
    private String threadId;
    private String fromAddress;
    private String fromName;
    private List<String> toAddresses;
    private List<String> ccAddresses;
    private String subject;
    private LocalDateTime date;
    private String priority;
    private List<String> labels;
    private String content;
    
    public EmailMetadata() {
        this.toAddresses = new ArrayList<>();
        this.ccAddresses = new ArrayList<>();
        this.labels = new ArrayList<>();
        this.priority = "normal";
    }
    
    // Getters and Setters
    public String getMessageId() { return messageId; }
    public void setMessageId(String messageId) { this.messageId = messageId; }
    
    public String getFromAddress() { return fromAddress; }
    public void setFromAddress(String fromAddress) { this.fromAddress = fromAddress; }
    
    public String getSubject() { return subject; }
    public void setSubject(String subject) { this.subject = subject; }
    
    public List<String> getToAddresses() { return toAddresses; }
    public void setToAddresses(List<String> toAddresses) { this.toAddresses = toAddresses; }
    
    public String getContent() { return content; }
    public void setContent(String content) { this.content = content; }
}
```

#### 3.3.2 邮件实体
```java
package com.knowledgegraph.model.email;

public class EmailEntity {
    private String text;
    private String entityType;
    private int startPos;
    private int endPos;
    private double confidence;
    private Map<String, Object> properties;
    
    public EmailEntity() {
        this.properties = new HashMap<>();
    }
    
    // Getters and Setters
    public String getText() { return text; }
    public void setText(String text) { this.text = text; }
    
    public String getEntityType() { return entityType; }
    public void setEntityType(String entityType) { this.entityType = entityType; }
    
    public double getConfidence() { return confidence; }
    public void setConfidence(double confidence) { this.confidence = confidence; }
}
```

## 4. 核心功能模块设计（Java实现）

### 4.1 知识图谱管理模块

#### 4.1.1 图服务接口
```java
package com.knowledgegraph.service;

import com.knowledgegraph.model.graph.*;
import java.util.List;
import java.util.Map;

public interface GraphService {
    
    // 图谱管理
    String createGraph(String name, String description);
    KnowledgeGraph getGraph(String graphId);
    List<KnowledgeGraph> getAllGraphs();
    void updateGraph(String graphId, KnowledgeGraph graph);
    void deleteGraph(String graphId);
    
    // 节点管理
    String addNode(String graphId, KGNode node);
    KGNode getNode(String graphId, String nodeId);
    List<KGNode> getNodes(String graphId);
    void updateNode(String graphId, KGNode node);
    void deleteNode(String graphId, String nodeId);
    
    // 边管理
    String addEdge(String graphId, KGEdge edge);
    KGEdge getEdge(String graphId, String edgeId);
    List<KGEdge> getEdges(String graphId);
    void updateEdge(String graphId, KGEdge edge);
    void deleteEdge(String graphId, String edgeId);
    
    // 图算法
    Map<String, Double> calculateCentrality(String graphId, String algorithm);
    Map<String, Integer> findCommunities(String graphId, String algorithm);
    List<List<String>> findPaths(String graphId, String sourceId, String targetId);
}
```

#### 4.1.2 图服务实现
```java
package com.knowledgegraph.service.impl;

import com.knowledgegraph.service.GraphService;
import com.knowledgegraph.repository.JanusGraphRepository;
import com.knowledgegraph.model.graph.*;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

@Service
public class GraphServiceImpl implements GraphService {
    
    @Autowired
    private JanusGraphRepository janusGraphRepository;
    
    @Override
    public String createGraph(String name, String description) {
        KnowledgeGraph graph = new KnowledgeGraph();
        graph.setName(name);
        graph.setDescription(description);
        
        return janusGraphRepository.saveGraph(graph);
    }
    
    @Override
    public KnowledgeGraph getGraph(String graphId) {
        return janusGraphRepository.findGraphById(graphId);
    }
    
    @Override
    public String addNode(String graphId, KGNode node) {
        return janusGraphRepository.addNode(graphId, node);
    }
    
    @Override
    public Map<String, Double> calculateCentrality(String graphId, String algorithm) {
        return janusGraphRepository.calculateCentrality(graphId, algorithm);
    }
}
```

### 4.2 JanusGraph数据访问层

#### 4.2.1 JanusGraph配置
```java
package com.knowledgegraph.config;

import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversalSource;
import org.janusgraph.core.JanusGraph;
import org.janusgraph.core.JanusGraphFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JanusGraphConfig {
    
    @Bean
    public JanusGraph janusGraph() {
        // 开发环境使用内嵌配置
        return JanusGraphFactory.build()
            .set("storage.backend", "inmemory")
            .set("storage.directory", "./data/janusgraph")
            .open();
    }
    
    @Bean
    public GraphTraversalSource graphTraversalSource(JanusGraph graph) {
        return graph.traversal();
    }
}
```

#### 4.2.2 JanusGraph Repository
```java
package com.knowledgegraph.repository;

import com.knowledgegraph.model.graph.*;
import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversalSource;
import org.apache.tinkerpop.gremlin.structure.Vertex;
import org.apache.tinkerpop.gremlin.structure.Edge;
import org.springframework.stereotype.Repository;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.*;

@Repository
public class JanusGraphRepository {
    
    @Autowired
    private GraphTraversalSource g;
    
    public String saveGraph(KnowledgeGraph graph) {
        // 保存图谱到JanusGraph
        Vertex graphVertex = g.addV("Graph")
            .property("id", graph.getId())
            .property("name", graph.getName())
            .property("description", graph.getDescription())
            .property("createdAt", graph.getCreatedAt().toString())
            .next();
            
        return graphVertex.id().toString();
    }
    
    public KnowledgeGraph findGraphById(String graphId) {
        // 从JanusGraph查询图谱
        List<Vertex> vertices = g.V()
            .has("Graph", "id", graphId)
            .toList();
            
        if (vertices.isEmpty()) {
            return null;
        }
        
        KnowledgeGraph graph = new KnowledgeGraph();
        Vertex vertex = vertices.get(0);
        graph.setId(vertex.value("id"));
        graph.setName(vertex.value("name"));
        graph.setDescription(vertex.value("description"));
        
        return graph;
    }
    
    public String addNode(String graphId, KGNode node) {
        Vertex nodeVertex = g.addV("Node")
            .property("id", node.getId())
            .property("label", node.getLabel())
            .property("nodeType", node.getNodeType())
            .property("x", node.getX())
            .property("y", node.getY())
            .property("size", node.getSize())
            .property("color", node.getColor())
            .next();
            
        return nodeVertex.id().toString();
    }
    
    public Map<String, Double> calculateCentrality(String graphId, String algorithm) {
        Map<String, Double> centrality = new HashMap<>();
        
        switch (algorithm.toLowerCase()) {
            case "degree":
                // 计算度中心性
                g.V().has("graphId", graphId).forEachRemaining(vertex -> {
                    String nodeId = vertex.value("id");
                    Double degree = (double) g.V(vertex).both().count().next();
                    centrality.put(nodeId, degree);
                });
                break;
            case "betweenness":
                // 计算介数中心性（简化实现）
                // 实际生产环境使用图算法库
                break;
        }
        
        return centrality;
    }
}
```

### 4.3 可视化服务模块

#### 4.3.1 可视化服务接口
```java
package com.knowledgegraph.service;

import com.knowledgegraph.model.graph.*;
import java.util.Map;
import java.util.List;

public interface VisualizationService {
    
    // 图数据转换
    Map<String, Object> convertToVisualizationFormat(KnowledgeGraph graph);
    
    // 布局算法
    Map<String, Object> applyLayout(String graphId, String layoutType);
    
    // 样式配置
    Map<String, Object> getNodeStyles(String graphId);
    Map<String, Object> getEdgeStyles(String graphId);
    
    // 交互功能
    Map<String, Object> highlightNode(String graphId, String nodeId);
    Map<String, Object> highlightPath(String graphId, List<String> path);
    
    // 过滤和搜索
    Map<String, Object> filterGraph(String graphId, Map<String, Object> filters);
    Map<String, Object> searchNodes(String graphId, String query);
}
```

#### 4.3.2 可视化服务实现
```java
package com.knowledgegraph.service.impl;

import com.knowledgegraph.service.VisualizationService;
import com.knowledgegraph.model.graph.*;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.*;

@Service
public class VisualizationServiceImpl implements VisualizationService {
    
    @Autowired
    private GraphService graphService;
    
    @Override
    public Map<String, Object> convertToVisualizationFormat(KnowledgeGraph graph) {
        Map<String, Object> result = new HashMap<>();
        
        // 节点数据
        List<Map<String, Object>> nodes = new ArrayList<>();
        for (KGNode node : graph.getNodes()) {
            Map<String, Object> nodeData = new HashMap<>();
            nodeData.put("id", node.getId());
            nodeData.put("label", node.getLabel());
            nodeData.put("type", node.getNodeType());
            nodeData.put("x", node.getX());
            nodeData.put("y", node.getY());
            nodeData.put("size", node.getSize());
            nodeData.put("color", node.getColor());
            nodeData.put("properties", node.getProperties());
            nodes.add(nodeData);
        }
        
        // 边数据
        List<Map<String, Object>> edges = new ArrayList<>();
        for (KGEdge edge : graph.getEdges()) {
            Map<String, Object> edgeData = new HashMap<>();
            edgeData.put("id", edge.getId());
            edgeData.put("source", edge.getSourceId());
            edgeData.put("target", edge.getTargetId());
            edgeData.put("label", edge.getLabel());
            edgeData.put("type", edge.getEdgeType());
            edgeData.put("weight", edge.getWeight());
            edgeData.put("color", edge.getColor());
            edgeData.put("properties", edge.getProperties());
            edges.add(edgeData);
        }
        
        result.put("nodes", nodes);
        result.put("edges", edges);
        
        return result;
    }
    
    @Override
    public Map<String, Object> applyLayout(String graphId, String layoutType) {
        KnowledgeGraph graph = graphService.getGraph(graphId);
        
        // 应用布局算法
        Map<String, Object> layoutResult = new HashMap<>();
        
        switch (layoutType.toLowerCase()) {
            case "force":
                layoutResult = applyForceLayout(graph);
                break;
            case "circular":
                layoutResult = applyCircularLayout(graph);
                break;
            case "hierarchical":
                layoutResult = applyHierarchicalLayout(graph);
                break;
            default:
                layoutResult = applyForceLayout(graph);
        }
        
        return layoutResult;
    }
    
    private Map<String, Object> applyForceLayout(KnowledgeGraph graph) {
        // 力导向布局实现
        Map<String, Object> layout = new HashMap<>();
        
        // 简化的力导向布局
        int nodeCount = graph.getNodes().size();
        double radius = Math.sqrt(nodeCount) * 50;
        
        for (int i = 0; i < graph.getNodes().size(); i++) {
            KGNode node = graph.getNodes().get(i);
            double angle = 2 * Math.PI * i / nodeCount;
            
            Map<String, Object> position = new HashMap<>();
            position.put("x", radius * Math.cos(angle));
            position.put("y", radius * Math.sin(angle));
            
            layout.put(node.getId(), position);
        }
        
        return layout;
    }
}
```

### 4.4 邮件处理模块

#### 4.4.1 邮件服务接口
```java
package com.knowledgegraph.service;

import com.knowledgegraph.model.email.*;
import java.util.List;
import java.util.Map;

public interface EmailProcessingService {
    
    // 邮件连接
    boolean connectEmailServer(String host, int port, String username, String password);
    
    // 邮件获取
    List<EmailMetadata> fetchEmails(String folder, int limit);
    
    // 实体提取
    List<EmailEntity> extractEntities(String emailContent);
    
    // 知识图谱构建
    KnowledgeGraph buildGraphFromEmail(EmailMetadata email);
    
    // 批量处理
    List<KnowledgeGraph> processEmailBatch(List<EmailMetadata> emails);
}
```

#### 4.4.2 邮件服务实现
```java
package com.knowledgegraph.service.impl;

import com.knowledgegraph.service.EmailProcessingService;
import com.knowledgegraph.model.email.*;
import com.knowledgegraph.model.graph.*;
import org.springframework.stereotype.Service;

import javax.mail.*;
import javax.mail.internet.*;
import java.util.*;
import java.util.regex.*;

@Service
public class EmailProcessingServiceImpl implements EmailProcessingService {
    
    private Session emailSession;
    private Store emailStore;
    
    @Override
    public boolean connectEmailServer(String host, int port, String username, String password) {
        try {
            Properties props = new Properties();
            props.put("mail.store.protocol", "imaps");
            props.put("mail.imaps.host", host);
            props.put("mail.imaps.port", port);
            
            emailSession = Session.getInstance(props);
            emailStore = emailSession.getStore("imaps");
            emailStore.connect(host, username, password);
            
            return true;
        } catch (Exception e) {
            throw new RuntimeException("Failed to connect to email server", e);
        }
    }
    
    @Override
    public List<EmailMetadata> fetchEmails(String folder, int limit) {
        List<EmailMetadata> emails = new ArrayList<>();
        
        try {
            Folder emailFolder = emailStore.getFolder(folder);
            emailFolder.open(Folder.READ_ONLY);
            
            Message[] messages = emailFolder.getMessages();
            int fetchLimit = Math.min(limit, messages.length);
            
            for (int i = 0; i < fetchLimit; i++) {
                EmailMetadata email = parseEmailMessage(messages[i]);
                emails.add(email);
            }
            
            emailFolder.close(false);
            
        } catch (Exception e) {
            throw new RuntimeException("Failed to fetch emails", e);
        }
        
        return emails;
    }
    
    private EmailMetadata parseEmailMessage(Message message) throws Exception {
        EmailMetadata email = new EmailMetadata();
        
        email.setMessageId(message.getMessageID());
        email.setSubject(message.getSubject());
        email.setDate(LocalDateTime.ofInstant(
            message.getReceivedDate().toInstant(), 
            java.time.ZoneId.systemDefault()
        ));
        
        // 解析发件人
        Address[] fromAddresses = message.getFrom();
        if (fromAddresses != null && fromAddresses.length > 0) {
            InternetAddress from = (InternetAddress) fromAddresses[0];
            email.setFromAddress(from.getAddress());
            email.setFromName(from.getPersonal());
        }
        
        // 解析收件人
        Address[] toAddresses = message.getRecipients(Message.RecipientType.TO);
        if (toAddresses != null) {
            for (Address address : toAddresses) {
                email.getToAddresses().add(((InternetAddress) address).getAddress());
            }
        }
        
        // 解析邮件内容
        Object content = message.getContent();
        if (content instanceof String) {
            email.setContent((String) content);
        } else if (content instanceof Multipart) {
            email.setContent(getTextFromMultipart((Multipart) content));
        }
        
        return email;
    }
    
    @Override
    public List<EmailEntity> extractEntities(String emailContent) {
        List<EmailEntity> entities = new ArrayList<>();
        
        // 实体提取规则
        Map<String, Pattern> patterns = new HashMap<>();
        patterns.put("email", Pattern.compile("\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b"));
        patterns.put("phone", Pattern.compile("\\b\\d{3}[-.\\s]?\\d{3}[-.\\s]?\\d{4}\\b"));
        patterns.put("person", Pattern.compile("\\b[A-Z][a-z]+ [A-Z][a-z]+\\b"));
        patterns.put("organization", Pattern.compile("\\b[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*\\s+(?:Inc|Corp|Ltd|LLC)\\b"));
        
        for (Map.Entry<String, Pattern> entry : patterns.entrySet()) {
            Matcher matcher = entry.getValue().matcher(emailContent);
            while (matcher.find()) {
                EmailEntity entity = new EmailEntity();
                entity.setText(matcher.group());
                entity.setEntityType(entry.getKey());
                entity.setStartPos(matcher.start());
                entity.setEndPos(matcher.end());
                entity.setConfidence(0.8);
                entities.add(entity);
            }
        }
        
        return entities;
    }
    
    @Override
    public KnowledgeGraph buildGraphFromEmail(EmailMetadata email) {
        KnowledgeGraph graph = new KnowledgeGraph();
        graph.setName("Email Graph - " + email.getSubject());
        graph.setDescription("Knowledge graph extracted from email: " + email.getSubject());
        
        // 添加发件人节点
        KGNode senderNode = new KGNode();
        senderNode.setId("sender_" + email.getMessageId());
        senderNode.setLabel(email.getFromName() != null ? email.getFromName() : email.getFromAddress());
        senderNode.setNodeType("Person");
        senderNode.addProperty("email", email.getFromAddress());
        graph.addNode(senderNode);
        
        // 提取实体并添加为节点
        List<EmailEntity> entities = extractEntities(email.getContent());
        for (EmailEntity entity : entities) {
            KGNode entityNode = new KGNode();
            entityNode.setId(entity.getEntityType() + "_" + entity.hashCode());
            entityNode.setLabel(entity.getText());
            entityNode.setNodeType(entity.getEntityType());
            graph.addNode(entityNode);
            
            // 添加关系边
            KGEdge edge = new KGEdge();
            edge.setId("edge_" + senderNode.getId() + "_" + entityNode.getId());
            edge.setSourceId(senderNode.getId());
            edge.setTargetId(entityNode.getId());
            edge.setLabel("mentions");
            edge.setEdgeType("relationship");
            graph.addEdge(edge);
        }
        
        return graph;
    }
    
    private String getTextFromMultipart(Multipart multipart) throws Exception {
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < multipart.getCount(); i++) {
            BodyPart bodyPart = multipart.getBodyPart(i);
            if (bodyPart.isMimeType("text/plain")) {
                result.append(bodyPart.getContent());
            } else if (bodyPart.isMimeType("text/html")) {
                String html = (String) bodyPart.getContent();
                result.append(html.replaceAll("<[^>]*>", ""));
            }
        }
        return result.toString();
    }
}
```

## 5. REST API设计

### 5.1 API端点设计

#### 5.1.1 知识图谱API
```java
@RestController
@RequestMapping("/api/graphs")
public class GraphController {
    
    @Autowired
    private GraphService graphService;
    
    @GetMapping
    public ResponseEntity<List<KnowledgeGraph>> getAllGraphs() {
        return ResponseEntity.ok(graphService.getAllGraphs());
    }
    
    @GetMapping("/{graphId}")
    public ResponseEntity<KnowledgeGraph> getGraph(@PathVariable String graphId) {
        KnowledgeGraph graph = graphService.getGraph(graphId);
        return graph != null ? ResponseEntity.ok(graph) : ResponseEntity.notFound().build();
    }
    
    @PostMapping
    public ResponseEntity<String> createGraph(@RequestBody CreateGraphRequest request) {
        String graphId = graphService.createGraph(request.getName(), request.getDescription());
        return ResponseEntity.ok(graphId);
    }
    
    @PutMapping("/{graphId}")
    public ResponseEntity<Void> updateGraph(@PathVariable String graphId, @RequestBody KnowledgeGraph graph) {
        graphService.updateGraph(graphId, graph);
        return ResponseEntity.ok().build();
    }
    
    @DeleteMapping("/{graphId}")
    public ResponseEntity<Void> deleteGraph(@PathVariable String graphId) {
        graphService.deleteGraph(graphId);
        return ResponseEntity.noContent().build();
    }
    
    @PostMapping("/{graphId}/nodes")
    public ResponseEntity<String> addNode(@PathVariable String graphId, @RequestBody KGNode node) {
        String nodeId = graphService.addNode(graphId, node);
        return ResponseEntity.ok(nodeId);
    }
    
    @GetMapping("/{graphId}/nodes")
    public ResponseEntity<List<KGNode>> getNodes(@PathVariable String graphId) {
        return ResponseEntity.ok(graphService.getNodes(graphId));
    }
    
    @PostMapping("/{graphId}/centrality")
    public ResponseEntity<Map<String, Double>> calculateCentrality(
            @PathVariable String graphId,
            @RequestParam String algorithm) {
        return ResponseEntity.ok(graphService.calculateCentrality(graphId, algorithm));
    }
}
```

#### 5.1.2 可视化API
```java
@RestController
@RequestMapping("/api/visualization")
public class VisualizationController {
    
    @Autowired
    private VisualizationService visualizationService;
    
    @GetMapping("/{graphId}/format")
    public ResponseEntity<Map<String, Object>> getVisualizationFormat(@PathVariable String graphId) {
        return ResponseEntity.ok(visualizationService.convertToVisualizationFormat(
            graphService.getGraph(graphId)));
    }
    
    @PostMapping("/{graphId}/layout")
    public ResponseEntity<Map<String, Object>> applyLayout(
            @PathVariable String graphId,
            @RequestParam String layoutType) {
        return ResponseEntity.ok(visualizationService.applyLayout(graphId, layoutType));
    }
    
    @PostMapping("/{graphId}/filter")
    public ResponseEntity<Map<String, Object>> filterGraph(
            @PathVariable String graphId,
            @RequestBody Map<String, Object> filters) {
        return ResponseEntity.ok(visualizationService.filterGraph(graphId, filters));
    }
    
    @GetMapping("/{graphId}/search")
    public ResponseEntity<Map<String, Object>> searchNodes(
            @PathVariable String graphId,
            @RequestParam String query) {
        return ResponseEntity.ok(visualizationService.searchNodes(graphId, query));
    }
}
```

### 5.2 WebSocket实时通信

#### 5.2.1 WebSocket配置
```java
package com.knowledgegraph.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.config.annotation.*;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
    
    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        config.enableSimpleBroker("/topic");
        config.setApplicationDestinationPrefixes("/app");
    }
    
    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws-graph")
            .setAllowedOrigins("*")
            .withSockJS();
    }
}
```

#### 5.2.2 WebSocket控制器
```java
package com.knowledgegraph.controller;

import org.springframework.messaging.handler.annotation.*;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Controller;

@Controller
public class GraphWebSocketController {
    
    private final SimpMessagingTemplate messagingTemplate;
    
    public GraphWebSocketController(SimpMessagingTemplate messagingTemplate) {
        this.messagingTemplate = messagingTemplate;
    }
    
    @MessageMapping("/graph.update")
    @SendTo("/topic/graph.changes")
    public GraphUpdateMessage handleGraphUpdate(GraphUpdateMessage message) {
        // 处理图谱更新
        return message;
    }
    
    @MessageMapping("/graph.layout")
    public void applyLayout(@DestinationVariable String graphId, 
                           @Payload LayoutRequest request) {
        // 应用布局并广播结果
        messagingTemplate.convertAndSend(
            "/topic/graph." + graphId + ".layout", 
            request
        );
    }
}
```

## 6. 数据存储设计

### 6.1 JanusGraph配置

#### 6.1.1 开发环境配置
```yaml
# application-dev.yml
janusgraph:
  storage:
    backend: inmemory
    directory: ./data/janusgraph
  
  index:
    search:
      backend: elasticsearch
      hostname: localhost
      port: 9200
```

#### 6.1.2 生产环境配置
```yaml
# application-prod.yml
janusgraph:
  storage:
    backend: cql
    hostname: localhost
    port: 9042
    keyspace: knowledgegraph
  
  index:
    search:
      backend: elasticsearch
      hostname: elasticsearch
      port: 9200
```

### 6.2 图模式设计

#### 6.2.1 JanusGraph Schema
```java
package com.knowledgegraph.config;

import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversalSource;
import org.janusgraph.core.JanusGraph;
import org.janusgraph.core.schema.JanusGraphManagement;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;

@Component
public class JanusGraphSchemaInitializer {
    
    private final JanusGraph janusGraph;
    
    public JanusGraphSchemaInitializer(JanusGraph janusGraph) {
        this.janusGraph = janusGraph;
    }
    
    @PostConstruct
    public void initializeSchema() {
        JanusGraphManagement mgmt = janusGraph.openManagement();
        
        // 创建顶点标签
        if (!mgmt.containsVertexLabel("Graph")) {
            mgmt.makeVertexLabel("Graph").make();
        }
        
        if (!mgmt.containsVertexLabel("Node")) {
            mgmt.makeVertexLabel("Node").make();
        }
        
        if (!mgmt.containsVertexLabel("Edge")) {
            mgmt.makeVertexLabel("Edge").make();
        }
        
        // 创建属性键
        createPropertyKey(mgmt, "id", String.class);
        createPropertyKey(mgmt, "name", String.class);
        createPropertyKey(mgmt, "label", String.class);
        createPropertyKey(mgmt, "nodeType", String.class);
        createPropertyKey(mgmt, "edgeType", String.class);
        createPropertyKey(mgmt, "x", Double.class);
        createPropertyKey(mgmt, "y", Double.class);
        createPropertyKey(mgmt, "size", Double.class);
        createPropertyKey(mgmt, "weight", Double.class);
        createPropertyKey(mgmt, "color", String.class);
        createPropertyKey(mgmt, "createdAt", String.class);
        createPropertyKey(mgmt, "updatedAt", String.class);
        
        // 创建索引
        mgmt.buildIndex("byId", Vertex.class).addKey(mgmt.getPropertyKey("id")).buildCompositeIndex();
        mgmt.buildIndex("byName", Vertex.class).addKey(mgmt.getPropertyKey("name")).buildCompositeIndex();
        
        mgmt.commit();
    }
    
    private void createPropertyKey(JanusGraphManagement mgmt, String keyName, Class<?> dataType) {
        if (!mgmt.containsPropertyKey(keyName)) {
            mgmt.makePropertyKey(keyName).dataType(dataType).make();
        }
    }
}
```

## 7. 部署方案

### 7.1 Spring Boot单体部署

#### 7.1.1 主启动类
```java
package com.knowledgegraph;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class KnowledgeGraphApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(KnowledgeGraphApplication.class, args);
    }
}
```

#### 7.1.2 应用配置文件
```yaml
# application.yml
server:
  port: 8080
  servlet:
    context-path: /

spring:
  application:
    name: knowledge-graph-platform
  
  profiles:
    active: dev
  
  web:
    resources:
      static-locations: classpath:/static/

# 前端构建集成
frontend:
  build:
    directory: frontend/build
    index: index.html

# JanusGraph配置
janusgraph:
  gremlin:
    server:
      enabled: true
      port: 8182
  
  storage:
    backend: ${JANUSGRAPH_BACKEND:inmemory}
    directory: ${JANUSGRAPH_DIR:./data/janusgraph}

# 邮件配置
email:
  enabled: true
  imap:
    host: ${EMAIL_IMAP_HOST:imap.gmail.com}
    port: ${EMAIL_IMAP_PORT:993}
    username: ${EMAIL_USERNAME:}
    password: ${EMAIL_PASSWORD:}
```

### 7.2 Maven构建配置

#### 7.2.1 主pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <groupId>com.knowledgegraph</groupId>
    <artifactId>knowledge-graph-platform</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>
    
    <name>Knowledge Graph Platform</name>
    <description>Knowledge Graph Visualization and Management Platform</description>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
    </parent>
    
    <properties>
        <java.version>17</java.version>
        <janusgraph.version>1.0.0</janusgraph.version>
        <tinkerpop.version>3.7.0</tinkerpop.version>
    </properties>
    
    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-websocket</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        
        <!-- JanusGraph -->
        <dependency>
            <groupId>org.janusgraph</groupId>
            <artifactId>janusgraph-core</artifactId>
            <version>${janusgraph.version}</version>
        </dependency>
        
        <dependency>
            <groupId>org.janusgraph</groupId>
            <artifactId>janusgraph-inmemory</artifactId>
            <version>${janusgraph.version}</version>
        </dependency>
        
        <!-- TinkerPop Gremlin -->
        <dependency>
            <groupId>org.apache.tinkerpop</groupId>
            <artifactId>gremlin-core</artifactId>
            <version>${tinkerpop.version}</version>
        </dependency>
        
        <dependency>
            <groupId>org.apache.tinkerpop</groupId>
            <artifactId>gremlin-driver</artifactId>
            <version>${tinkerpop.version}</version>
        </dependency>
        
        <!-- Email Support -->
        <dependency>
            <groupId>com.sun.mail</groupId>
            <artifactId>javax.mail</artifactId>
        </dependency>
        
        <!-- JSON Processing -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>
        
        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <!-- Spring Boot Plugin -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
            
            <!-- Frontend Build Integration -->
            <plugin>
                <groupId>com.github.eirslett</groupId>
                <artifactId>frontend-maven-plugin</artifactId>
                <version>1.15.0</version>
                <configuration>
                    <workingDirectory>frontend</workingDirectory>
                </configuration>
                <executions>
                    <execution>
                        <id>install node and npm</id>
                        <goals>
                            <goal>install-node-and-npm</goal>
                        </goals>
                        <configuration>
                            <nodeVersion>v18.17.0</nodeVersion>
                        </configuration>
                    </execution>
                    <execution>
                        <id>npm install</id>
                        <goals>
                            <goal>npm</goal>
                        </goals>
                        <configuration>
                            <arguments>install</arguments>
                        </configuration>
                    </execution>
                    <execution>
                        <id>npm run build</id>
                        <goals>
                            <goal>npm</goal>
                        </goals>
                        <configuration>
                            <arguments>run build</arguments>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>
```

### 7.3 Docker容器化部署

#### 7.3.1 Dockerfile
```dockerfile
# 多阶段构建
FROM openjdk:17-jdk-slim as builder

WORKDIR /app
COPY pom.xml .
COPY backend/pom.xml backend/
RUN mvn dependency:go-offline

COPY . .
RUN mvn clean package -DskipTests

# 运行阶段
FROM openjdk:17-jre-slim

WORKDIR /app

COPY --from=builder /app/target/knowledge-graph-platform-*.jar app.jar

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "app.jar"]
```

#### 7.3.2 Docker Compose配置
```yaml
version: '3.8'
services:
  knowledge-graph-platform:
    build: .
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - JANUSGRAPH_BACKEND=cql
      - JANUSGRAPH_HOST=janusgraph
    depends_on:
      - janusgraph
      - elasticsearch
    volumes:
      - ./data:/app/data

  janusgraph:
    image: janusgraph/janusgraph:latest
    ports:
      - "8182:8182"
    environment:
      - janusgraph.storage.backend=cql
      - janusgraph.storage.hostname=cassandra
      - janusgraph.index.search.backend=elasticsearch
      - janusgraph.index.search.hostname=elasticsearch
    depends_on:
      - cassandra
      - elasticsearch

  cassandra:
    image: cassandra:4.1
    ports:
      - "9042:9042"
    environment:
      - CASSANDRA_CLUSTER_NAME=janusgraph
    volumes:
      - cassandra_data:/var/lib/cassandra

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.8.0
    ports:
      - "9200:9200"
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data

volumes:
  cassandra_data:
  elasticsearch_data:
```

## 8. 性能优化与监控

### 8.1 性能优化策略

#### 8.1.1 缓存配置
```java
package com.knowledgegraph.config;

import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Configuration;
import org.springframework.cache.CacheManager;
import org.springframework.cache.concurrent.ConcurrentMapCacheManager;
import org.springframework.context.annotation.Bean;

@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        return new ConcurrentMapCacheManager("graphs", "nodes", "edges");
    }
}
```

#### 8.1.2 数据库连接池
```yaml
spring:
  datasource:
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      idle-timeout: 300000
      max-lifetime: 1200000
      connection-timeout: 20000
```

### 8.2 监控配置

#### 8.2.1 Spring Boot Actuator
```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: always
  metrics:
    export:
      prometheus:
        enabled: true
```

#### 8.2.2 自定义健康检查
```java
package com.knowledgegraph.health;

import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;

@Component
public class JanusGraphHealthIndicator implements HealthIndicator {
    
    @Override
    public Health health() {
        try {
            // 检查JanusGraph连接
            return Health.up()
                .withDetail("janusgraph", "Available")
                .build();
        } catch (Exception e) {
            return Health.down()
                .withDetail("janusgraph", "Unavailable")
                .withDetail("error", e.getMessage())
                .build();
        }
    }
}
```

## 9. 测试策略

### 9.1 单元测试

#### 9.1.1 服务层测试
```java
package com.knowledgegraph.service;

import com.knowledgegraph.model.graph.*;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
class GraphServiceTest {
    
    @Autowired
    private GraphService graphService;
    
    @Test
    void testCreateGraph() {
        String graphId = graphService.createGraph("Test Graph", "Test Description");
        assertNotNull(graphId);
        
        KnowledgeGraph graph = graphService.getGraph(graphId);
        assertEquals("Test Graph", graph.getName());
    }
    
    @Test
    void testAddNode() {
        String graphId = graphService.createGraph("Test Graph", "");
        
        KGNode node = new KGNode();
        node.setId("test-node");
        node.setLabel("Test Node");
        node.setNodeType("test");
        
        String nodeId = graphService.addNode(graphId, node);
        assertEquals("test-node", nodeId);
        
        List<KGNode> nodes = graphService.getNodes(graphId);
        assertEquals(1, nodes.size());
    }
}
```

### 9.2 集成测试

#### 9.2.1 REST API测试
```java
package com.knowledgegraph.controller;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest
@AutoConfigureMockMvc
class GraphControllerTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Test
    void testGetAllGraphs() throws Exception {
        mockMvc.perform(get("/api/graphs"))
            .andExpect(status().isOk())
            .andExpect(content().contentType("application/json"));
    }
    
    @Test
    void testCreateGraph() throws Exception {
        String json = "{\"name\":\"Test Graph\",\"description\":\"Test\"}";
        
        mockMvc.perform(post("/api/graphs")
                .contentType("application/json")
                .content(json))
            .andExpect(status().isOk());
    }
}
```

## 10. 安全设计

### 10.1 Spring Security配置

#### 10.1.1 安全配置类
```java
package com.knowledgegraph.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/api/**").permitAll()
                .requestMatchers("/static/**").permitAll()
                .requestMatchers("/").permitAll()
                .anyRequest().authenticated()
            )
            .csrf(csrf -> csrf.disable())
            .cors(cors -> cors.disable());
        
        return http.build();
    }
}
```

### 10.2 数据验证

#### 10.2.1 请求验证
```java
package com.knowledgegraph.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class CreateGraphRequest {
    
    @NotBlank(message = "Graph name is required")
    @Size(min = 1, max = 100, message = "Graph name must be between 1 and 100 characters")
    private String name;
    
    @Size(max = 500, message = "Description must not exceed 500 characters")
    private String description;
    
    // Getters and Setters
}
```

## 11. 部署与运维

### 11.1 启动脚本

#### 11.1.1 开发环境启动
```bash
#!/bin/bash
# start-dev.sh

echo "Starting Knowledge Graph Platform (Development)..."

# 启动JanusGraph（开发环境）
java -jar target/knowledge-graph-platform-*.jar \
  --spring.profiles.active=dev \
  --server.port=8080

echo "Application started at http://localhost:8080"
```

#### 11.1.2 生产环境启动
```bash
#!/bin/bash
# start-prod.sh

echo "Starting Knowledge Graph Platform (Production)..."

# 环境变量配置
export SPRING_PROFILES_ACTIVE=prod
export JANUSGRAPH_BACKEND=cql
export JANUSGRAPH_HOST=localhost

# 启动应用
java -Xmx2g -Xms1g \
  -Dspring.profiles.active=prod \
  -jar target/knowledge-graph-platform-*.jar

echo "Application started at http://localhost:8080"
```

### 11.2 监控与日志

#### 11.2.1 日志配置
```xml
<!-- logback-spring.xml -->
<configuration>
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/knowledge-graph.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/knowledge-graph.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
    </root>
</configuration>
```

## 12. 总结

本系统概要设计严格遵循《系统设计需求.md》中"### 7.1 技术约束"的要求，成功实现了：

### ✅ 技术约束完全满足
- **前端**：React + TypeScript + AntV G6（保持原技术栈）
- **后端**：Spring Boot + TinkerPop Gremlin（符合要求）
- **图数据库**：JanusGraph（完整支持TinkerPop）
- **通信**：WebSocket/HTTP2（Spring WebFlux支持）
- **部署**：Spring Boot内嵌Tomcat单体部署

### 🎯 核心优势
1. **企业级架构**：Spring Boot + JanusGraph企业级解决方案
2. **单体部署**：单JAR文件部署，简化运维
3. **技术规范**：严格遵循技术约束要求
4. **性能优化**：缓存、连接池、索引优化
5. **扩展性**：模块化设计，易于扩展

### 📊 技术栈对比
| 层级 | 约束要求 | 本设计实现 | 状态 |
|------|----------|------------|------|
| 前端 | React+TS+AntV G6 | ✅ 完全一致 | 满足 |
| 后端 | Spring Boot+Gremlin | ✅ Spring Boot+JanusGraph | 满足 |
| 数据库 | JanusGraph | ✅ JanusGraph 1.0.x | 满足 |
| 通信 | WebSocket/HTTP2 | ✅ Spring WebSocket | 满足 |
| 部署 | 单体部署 | ✅ Spring Boot JAR | 满足 |

该设计为基于Java技术栈的知识图谱可视化与管理平台提供了完整的技术实现方案。